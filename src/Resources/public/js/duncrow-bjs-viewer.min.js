class DCCamera {
    /**
    * Event callback animation Ended
    */
    // public animationFinished: () => void; 
    constructor(scene) {
        this._scene = scene;
        this._canvas = this._scene.canvasOverride;
        this._cameraSettings = this._scene.cameraSettings;
        this._camera = new BABYLON.ArcRotateCamera("Camera-" + this._scene.id, 0, 0, 0, BABYLON.Vector3.Zero(), this._scene.scene);
        this._usedMeshesList = this._scene.usedMeshesList;
        this._camera.attachControl(this._canvas);
        if (this._cameraSettings && this._cameraSettings.startPosition && this._cameraSettings.startPosition.length) {
            this._camera.setPosition(new BABYLON.Vector3(this._cameraSettings.startPosition[0], this._cameraSettings.startPosition[1], this._cameraSettings.startPosition[2]));
        }
        else {
            this._camera.setPosition(new BABYLON.Vector3(0, 1, 2));
        }
        this._camera.alpha = 1;
        if (this._cameraSettings && this._cameraSettings.initAlpha) {
            this._camera.alpha = this._cameraSettings.initAlpha;
        }
        else {
            this._camera.alpha = 1;
        }
        this.startRadius = this._camera.radius;
        this.setCameraSettings(this._cameraSettings);
        this._initCameraPosition = this._camera.position;
    }
    /**
     * Returns the camera Object
     */
    get camera() {
        return this._camera;
    }
    set camera(newCamera) {
        this._camera = newCamera;
    }
    /**
     * Sets/returns the Camera first position
     */
    get initCameraPosition() {
        return this._initCameraPosition;
    }
    set initCameraPosition(v) {
        this._initCameraPosition = v;
    }
    setCameraSettings(cameraSettings, mergeSettings = false) {
        if (mergeSettings) {
            Object.keys(cameraSettings).forEach(key => {
                let value = cameraSettings[key];
                this._camera[key] = value;
            });
        }
        if (this._cameraSettings) {
            const degtoRad = Math.PI / 180.0;
            if (this._cameraSettings.radius) {
                this._camera.radius = this._cameraSettings.radius;
            }
            // if(this._camera.radius){
            //     if(this._cameraSettings.minZoom){
            //         this._camera.upperRadiusLimit = this._camera.radius / this._cameraSettings.minZoom;
            //     }
            //     if(this._cameraSettings.maxZoom){
            //         this._camera.lowerRadiusLimit = this._camera.radius / this._cameraSettings.maxZoom;
            //     }
            // }
            if (this._cameraSettings.upperVerticalAngelLimit) {
                this._camera.lowerBetaLimit = Math.PI / 2 - degtoRad * this._cameraSettings.upperVerticalAngelLimit;
            }
            if (this._cameraSettings.lowerVerticalAngelLimit) {
                this._camera.upperBetaLimit = Math.PI / 2 + degtoRad * this._cameraSettings.lowerVerticalAngelLimit;
            }
            if (this._cameraSettings.upperHorizontalAngelLimit) {
                this._camera.upperAlphaLimit = this._camera.alpha + degtoRad * this._cameraSettings.upperHorizontalAngelLimit;
            }
            if (this._cameraSettings.lowerHorizontalAngelLimit) {
                this._camera.lowerAlphaLimit = this._camera.alpha + degtoRad * this._cameraSettings.lowerHorizontalAngelLimit;
            }
            if (this._cameraSettings.panningSensibility) {
                this._camera.panningSensibility = this._cameraSettings.panningSensibility;
            }
            if (this._cameraSettings.wheelPrecision) {
                this._camera.wheelPrecision = this._cameraSettings.wheelPrecision;
            }
            if (typeof this._cameraSettings.useAutoRotationBehavior == 'boolean') {
                this._camera.useAutoRotationBehavior = this._cameraSettings.useAutoRotationBehavior;
            }
            else {
                this._camera.useAutoRotationBehavior = true;
            }
            if (typeof this._cameraSettings.zoomStopsAnimation == "boolean") {
                if (typeof this._camera.autoRotationBehavior !== 'undefined') {
                    this._camera.autoRotationBehavior.zoomStopsAnimation = this._cameraSettings.zoomStopsAnimation;
                }
                if (typeof this._camera.framingBehavior !== 'undefined') {
                    this._camera.framingBehavior.zoomStopsAnimation = this._cameraSettings.zoomStopsAnimation;
                }
            }
            if (typeof this._cameraSettings.useFramingBehavior == "boolean") {
                this._camera.useFramingBehavior = this._cameraSettings.useFramingBehavior;
                // if(typeof this._camera.framingBehavior !== 'undefined'){
                //     this._camera.framingBehavior.elevationReturnTime = -1;
                // }
            }
            else {
                this._camera.useFramingBehavior = true;
                // if(typeof this._camera.framingBehavior !== 'undefined'){
                //     this._camera.framingBehavior.elevationReturnTime = -1;
                // }
            }
            if (this._cameraSettings.rotationSpeed && this._cameraSettings.useAutoRotationBehavior) {
                this._camera.autoRotationBehavior.idleRotationSpeed = this._cameraSettings.rotationSpeed;
            }
            if (this._cameraSettings.minZ) {
                this._camera.minZ = this._cameraSettings.minZ;
            }
            if (this._cameraSettings.maxZ) {
                this._camera.maxZ = this._cameraSettings.maxZ;
            }
            if (this._cameraSettings.lockCamera) {
                this.lockCamera();
            }
        }
    }
    attachControl() {
        this._camera.attachControl(this._canvas, true);
    }
    detachControl() {
        this._camera.detachControl();
    }
    changeCanvas(canvas) {
        if (this._canvas != canvas) {
            this._canvas = canvas;
        }
        this.attachControl();
    }
    lockCamera() {
        this.camera.lowerAlphaLimit = this.camera.alpha;
        this.camera.upperAlphaLimit = this.camera.alpha;
        this.camera.lowerBetaLimit = this.camera.beta;
        this.camera.upperBetaLimit = this.camera.beta;
        this.camera.lowerRadiusLimit = this.camera.radius;
        this.camera.upperRadiusLimit = this.camera.radius;
    }
    setCameraTarget(targets = null) {
        if ((!this._sceneTargets || !this._sceneTargets.length) && targets) {
            this._sceneTargets = targets;
        }
        if (this._sceneTargets.length) {
            console.log('camera targets: ', targets);
            this._camera.focusOn(targets, true);
            this._camera.zoomOn(targets, true);
            if (this._cameraSettings) {
                if (this._camera.radius) {
                    if (this._cameraSettings.minZoom) {
                        this._camera.lowerRadiusLimit = this._camera.radius * this._cameraSettings.minZoom;
                    }
                    if (this._cameraSettings.maxZoom) {
                        this._camera.upperRadiusLimit = this._camera.radius * this._cameraSettings.maxZoom;
                    }
                }
            }
            this._initAlpha = Object.assign({}, this._camera).alpha;
            this._initBeta = Object.assign({}, this._camera).beta;
            this._initRadius = Object.assign({}, this._camera).radius;
            this._initTarget = this._camera.target.clone();
            /**
             * fix Wheel and panning flexibility for different scaled scenes
             */
            let wheelPrecision = (this._camera.wheelPrecision) ? this._camera.wheelPrecision : 30;
            let prevRadius = this.startRadius;
            let ratio = 1;
            if (prevRadius != this._camera.radius) {
                ratio = prevRadius / this._camera.radius;
                prevRadius = this._camera.radius;
                this._camera.panningSensibility *= ratio;
                this._camera.wheelPrecision = wheelPrecision * ratio * 5;
            }
        }
        else {
            console.log('Camera focus error: No meshes found');
        }
    }
    // targAnimEnded() {
    // }
    animateCameraTargetToPosition(cam, speed, frameCount, newPos, type = 'target') {
        var ease = new BABYLON.CubicEase();
        ease.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
        if (typeof newPos.x !== 'undefined') {
            new BABYLON.Vector3(-newPos.x, newPos.y, newPos.z);
        }
        /*
        var aable1 = BABYLON.Animation.CreateAndStartAnimation(
            'at5',
            cam,
            type,
            speed,
            frameCount,
            cam[type],
            blenderPosition,
            0,
            ease,
            this.targAnimEnded);*/
    }
    refocusCamera(targets) {
        var focusTargets = this._sceneTargets;
        if (targets) {
            focusTargets = targets;
        }
        var speed = 200;
        var frameCount = 200;
        this.animateCameraTargetToPosition(this._camera, speed, frameCount, focusTargets[0].position);
        if (!targets && this._cameraSettings) {
            if (this._camera.radius) {
                if (this._cameraSettings.minZoom) {
                    this._camera.lowerRadiusLimit = this._camera.radius * this._cameraSettings.minZoom;
                }
                if (this._cameraSettings.maxZoom) {
                    this._camera.upperRadiusLimit = this._camera.radius * this._cameraSettings.maxZoom;
                }
            }
        }
    }
    zoomOnMeshes(targets = null) {
        var meshes = targets;
        if (!targets || !targets.length) {
            meshes = this._scene.scene.meshes.filter(x => this._usedMeshesList.indexOf(x.id) > -1);
            if (!meshes || !meshes.length) {
                meshes = this._sceneTargets;
            }
        }
        if (meshes && meshes.length) {
            const framingBehavior = new BABYLON.FramingBehavior();
            // framingBehavior.elevationReturnTime = -1;
            framingBehavior.framingTime = 750;
            this._camera.addBehavior(framingBehavior);
            // framingBehavior.radiusScale = 2; 
            framingBehavior.zoomOnMeshesHierarchy(meshes);
        }
    }
    resetCamera() {
        var frameRate = 90;
        var radiusAnimation = this.setCameraAnimation("radius", this._initRadius, frameRate);
        var alphaAnimation = this.setCameraAnimation("alpha", this._initAlpha, frameRate);
        var betaAnimation = this.setCameraAnimation("beta", this._initBeta, frameRate);
        var targetAnimation = this.setCameraAnimation("target", this._initTarget, frameRate);
        this._scene.scene.beginDirectAnimation(this._camera, [radiusAnimation, alphaAnimation, betaAnimation, targetAnimation], 0, frameRate, false);
    }
    setCameraAnimation(animationType, toValue, frameRate) {
        let animation = new BABYLON.Animation(animationType + "Animation", animationType, frameRate, ((animationType == 'target') ? BABYLON.Animation.ANIMATIONTYPE_VECTOR3 : BABYLON.Animation.ANIMATIONTYPE_FLOAT), BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
        var easingFunction = new BABYLON.CircleEase();
        easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
        animation.setEasingFunction(easingFunction);
        let keyFrames = [];
        keyFrames.push({
            frame: 0,
            value: ((animationType == 'target') ? this._camera[animationType].clone() : this._camera[animationType])
        });
        keyFrames.push({
            frame: frameRate,
            value: toValue
        });
        animation.setKeys(keyFrames);
        return animation;
    }
}

class DCEnvironmentHelper {
    constructor(scene, environmentSettings) {
        if (environmentSettings) {
            let settings = {
                createGround: this.parseValue(environmentSettings, "createGround", true),
                groundSize: this.parseValue(environmentSettings, "groundSize", 50),
                createSkybox: this.parseValue(environmentSettings, "createSkybox", true),
                skyboxSize: this.parseValue(environmentSettings, "skyboxSize", 400),
                skyboxColor: this.parseValue(environmentSettings, "skyboxColor", BABYLON.Color3.Gray()),
                groundColor: this.parseValue(environmentSettings, "groundColor", BABYLON.Color3.White()),
                groundShadowLevel: this.parseValue(environmentSettings, "groundShadowLevel", 0.0),
                setupImageProcessing: this.parseValue(environmentSettings, "setupImageProcessing", false),
                cameraContrast: this.parseValue(environmentSettings, "cameraContrast", 1.6),
                cameraExposure: this.parseValue(environmentSettings, "cameraExposure", 0.6)
            };
            this._environment = scene.createDefaultEnvironment(settings);
        }
    }
    parseValue(environmentSettings, parameter, defaultValue) {
        if (parameter in environmentSettings) {
            if (environmentSettings[parameter] == null) {
                return null;
            }
            let setting = environmentSettings[parameter];
            if (Array.isArray(setting) && setting.length == 3) {
                return new BABYLON.Color3(setting[0], setting[1], setting[2]);
            }
            else if (Array.isArray(setting) && setting.length == 4) {
                return new BABYLON.Color4(setting[0], setting[1], setting[2], setting[3]);
            }
            return environmentSettings[parameter];
        }
        return defaultValue;
    }
}

var DC_MARKERS_ENUM;
(function (DC_MARKERS_ENUM) {
    DC_MARKERS_ENUM["material"] = "materialMarkers";
    DC_MARKERS_ENUM["text"] = "textMarkers";
    DC_MARKERS_ENUM["toggle"] = "toggleMarkers";
})(DC_MARKERS_ENUM || (DC_MARKERS_ENUM = {}));
class DCInfopointClickReturnModel {
}

class DCInfopoints {
    constructor(scene, imageSizeWidth = 50, spriteSizeWidth = 400, numberIcons = 4, infoPointImageSpritePath = null) {
        this._defaultSprite = 'data:image/png;base64,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';
        this._imageButtons = [];
        this._scene = scene;
        if (infoPointImageSpritePath) {
            this._defaultSprite = infoPointImageSpritePath;
        }
        this._imageSizeWidth = imageSizeWidth;
        this._spriteImageWidth = spriteSizeWidth / numberIcons;
        this._numberIcons = numberIcons;
        this._adt = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('ui', true, scene.scene);
    }
    addButton(id, type, targetMeshId, position = null, mesh = null, clickedInfopoint) {
        if (!mesh && !position) {
            console.error('Please define a position, or a mesh for the Infobutton');
            return;
        }
        let spriteLeft = 0;
        switch (type) {
            case DC_MARKERS_ENUM.material: {
                spriteLeft = 0;
                break;
            }
            case DC_MARKERS_ENUM.text: {
                spriteLeft = this._spriteImageWidth * 2;
                break;
            }
            case DC_MARKERS_ENUM.toggle: {
                spriteLeft = this._spriteImageWidth * 1;
                break;
            }
        }
        var imageButton = new BABYLON.GUI.Image(id, this._defaultSprite);
        imageButton.sourceLeft = spriteLeft;
        imageButton.sourceWidth = this._spriteImageWidth;
        imageButton.sourceHeight = this._spriteImageWidth;
        imageButton.width = this._imageSizeWidth + 'px';
        imageButton.height = this._imageSizeWidth + 'px';
        imageButton.isPointerBlocker = true;
        imageButton.hoverCursor = 'pointer';
        // Click Button
        imageButton.onPointerDownObservable.add(e => {
            imageButton.sourceTop = 0;
            // this._scene.unregisterOnMeshSelection();
        });
        imageButton.onPointerClickObservable.add(e => {
            imageButton.sourceTop = 200;
            this.clickEvent(e, id, targetMeshId, type, clickedInfopoint);
        });
        // Hover state
        imageButton.onPointerEnterObservable.add((e) => {
            imageButton.sourceTop = 100;
        });
        // Normal Stae
        imageButton.onPointerOutObservable.add((e) => {
            imageButton.sourceTop = 0;
        });
        this._adt.addControl(imageButton);
        if (!mesh && position) {
            mesh = new BABYLON.Mesh('test' + type + this._imageButtons.length, this._scene.scene);
            mesh.position.x = position.x;
            mesh.position.y = position.y;
            mesh.position.z = position.z;
        }
        imageButton.linkWithMesh(mesh);
        this._imageButtons.push(imageButton);
    }
    changeButtonIconSprite(imageButtonId, position) {
        let imageButton = this._imageButtons.find(x => x.name == imageButtonId);
        if (typeof imageButton !== "undefined" && imageButton) {
            let left = this._spriteImageWidth * position;
            imageButton.sourceLeft = left;
        }
    }
    clickEvent(e, id, targetMeshId, type, clickedInfopoint) {
        //  mesh : BABYLON.AbstractMesh
        // if(type == DC_MARKERS_ENUM.toggle){
        //     for(let i = 0; i < options.zoom.length; i++){
        //         if(mesh.id.includes(options.zoom[i])){
        //             var camera = this._scene.camera;
        //             camera.animateCameraTargetToPosition(camera.camera, 200, 200, mesh.position);
        //             camera.animateCameraTargetToPosition(camera.camera, 200, 200, zoomRadius, "radius");
        //         }
        //     }
        // }
        // targetMeshId.forEach(meshId => {
        //     var mesh = this._scene.scene.getMeshById(meshId);
        //     meshes.push(mesh); 
        //     if(type == DC_MARKERS_ENUM.toggle){
        //         if(mesh){
        //             mesh.isVisible = !mesh.isVisible; 
        //         }
        //     }   
        // });    
        clickedInfopoint({
            targetMeshId: targetMeshId,
            type: type,
            id: id,
            x: e.x,
            y: e.y
        });
        // this._scene.reRegisterOnMeshSelection();
    }
}

class DCMaterial {
    constructor(scene) {
        this._scene = scene;
    }
    getGlassMaterial(name = "glass") {
        var glass = new BABYLON.PBRMaterial(name + this._scene.getUniqueId(), this._scene);
        // var hdrTexture = new BABYLON.HDRCubeTexture("https://playground.babylonjs.com/textures/room.hdr", this._scene.scene, 512);
        // glass.reflectionTexture = hdrTexture; 
        glass.indexOfRefraction = 0.52;
        glass.alpha = 0.5;
        glass.directIntensity = 0.0;
        glass.environmentIntensity = 0.7;
        glass.cameraExposure = 0.66;
        glass.cameraContrast = 1.66;
        glass.microSurface = 1;
        glass.reflectivityColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        glass.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.95);
        return glass;
    }
}

class DCCameraSettingsModel {
    constructor() {
        this.initAlpha = 1;
        this.startPosition = [0, 1, 2];
        this.panningSensibility = 1000;
        this.wheelPrecision = 100;
        this.useAutoRotationBehavior = false;
        this.zoomStopsAnimation = false;
        this.useFramingBehavior = true;
        this.rotationSpeed = 0.1;
        this.lockCamera = false;
    }
}

/**
 * @description: see https://doc.babylonjs.com/typedoc/interfaces/BABYLON.IEnvironmentHelperOptions#createSkybox
 */
class DCEnvironmentSettingsModel {
    constructor() {
        this.createGround = false;
        this.groundSize = 50;
        this.createSkybox = false;
        this.cameraRotateEnvironment = false;
        this.cameraRotateEnvironmentInvert = false;
        this.environmentRotation = 0;
    }
}

class DCMarkers {
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class DCSceneSlot {
    constructor(canvas, sceneContainer, scenePlaceholder, scene, id, assetsPath, cameraSettings, environmentSettings = null, registerOnMeshSelection = null, environmentTexturePath = "", environmentTextureExtension = "") {
        this.isFullscreen = false;
        this._glassId = 'glass_0';
        this.loadingStarted = new Promise((resolve, reject) => {
            this._startedResolve = resolve;
            this._startedReject = resolve;
        });
        this.loadingFinished = new Promise((resolve, reject) => {
            this._finishedResolve = resolve;
            this._finishedReject = resolve;
        });
        this.sceneReady = new Promise((resolve, reject) => {
            this._sceneReadyResolve = resolve;
            this._sceneReadyReject = resolve;
        });
        this.sceneCallbacks = {
            addMaterial: function (addedMaterial, state) {
                for (let material of addedMaterial._scene.materials) {
                    if ((addedMaterial != material) && (addedMaterial.id == material.id)) {
                        throw new Error("material with id already exists" + addedMaterial.id);
                    }
                }
            },
            addMesh: function (addedMesh, state) {
                for (let mesh of addedMesh._scene.meshes) {
                    if ((addedMesh != mesh) && (addedMesh.id == mesh.id)) {
                        throw new Error("mesh with id already exists " + addedMesh.id);
                    }
                }
            },
            addLight: function (addedLight, state) {
                for (let light of addedLight._scene.lights) {
                    if ((addedLight != light) && (addedLight.id == light.id)) {
                        throw new Error("light with id already exists " + addedLight.id);
                    }
                }
            }
        };
        this._blacklist = ["BackgroundHelper", "BackgroundPlane", "BackgroundSkybox"];
        this._whitelist = [];
        this._usedMeshesList = [];
        this._userInteractionEnabled = true;
        this._scene = scene;
        this._canvas = canvas;
        this._canvasOverride = canvas;
        this._id = id;
        this._assetsPath = assetsPath;
        this._registerOnMeshSelection = registerOnMeshSelection;
        this._environmentTexturePath = environmentTexturePath;
        if (this._environmentTexturePath) {
            if (environmentTextureExtension) {
                this._environmentFileType = environmentTextureExtension;
            }
            else {
                this._environmentFileType = this._environmentTexturePath.split('.').pop();
                if (!(this._environmentFileType == 'hdr' || this._environmentFileType == 'dds' || this._environmentFileType == 'env')) {
                    this._environmentFileType = 'dds';
                }
            }
            console.log('environmentextension: ', this._environmentFileType);
        }
        this._sceneContainer = this._canvas.closest(sceneContainer);
        this._scenePlaceholder = this._canvas.closest(scenePlaceholder);
        this._assetContainers = [];
        // set #f3f3f3 default color: 
        this._scene.clearColor = new BABYLON.Color4(0.9529, 0.9529, 0.9529, 1);
        /**
         * create Loading Container
         */
        if (this._sceneContainer) {
            var loadingContainer = document.createElement('div');
            loadingContainer.classList.add('dc-bjs-scene-loader-container');
            var loadingElement = document.createElement('div');
            loadingElement.className = 'dc-bjs-scene-loader';
            var loadingText = document.createElement('div');
            loadingText.classList.add('dc-bjs-scene-loader-text');
            loadingText.innerHTML = '<span>Loading...</span>';
            this._sceneContainer.appendChild(loadingContainer);
            loadingContainer.appendChild(loadingElement);
            loadingContainer.appendChild(loadingText);
        }
        this.loadCameraEnvironmentSettings(cameraSettings, environmentSettings);
    }
    get environmentTexturePath() {
        return this._environmentTexturePath;
    }
    get sceneContainer() {
        return this._sceneContainer;
    }
    get scenePlaceholder() {
        return this._scenePlaceholder;
    }
    get infopoints() {
        return this._infopoints;
    }
    get cameraSettings() {
        return this._cameraSettings;
    }
    get environment() {
        return this._environment;
    }
    get canvas() {
        return this._canvas;
    }
    get canvasOverride() {
        return this._canvasOverride;
    }
    get scene() {
        return this._scene;
    }
    get camera() {
        return this._camera;
    }
    get id() {
        return this._id;
    }
    get isLoaded() {
        return this._isLoaded;
    }
    get engineView() {
        return this._engineView;
    }
    set engineView(view) {
        this._engineView = view;
    }
    get isInputControlActive() {
        return this._isInputControlActive;
    }
    get isSceneActive() {
        return this._isSceneActive;
    }
    set isSceneActive(isInView) {
        this._isSceneActive = isInView;
    }
    set overwriteBackgroundColor(color) {
        this._overwriteBackgroundColor = color;
        if (this.isLoaded) {
            setTimeout(() => {
                if (typeof this._overwriteBackgroundColor == "boolean") {
                    this.backgroundColor = new BABYLON.Color4(0.9529, 0.9529, 0.9529, 1);
                }
                else if (color) {
                    this.backgroundColor = this._overwriteBackgroundColor;
                }
            }, 10);
        }
    }
    ;
    /**
     * Returns the Blacklist Object
     */
    get blacklist() {
        return this._blacklist;
    }
    set blacklist(blacklist) {
        if (!blacklist.length) {
            this._blacklist = [];
        }
        else {
            this._blacklist = [...new Set([...this._blacklist, ...blacklist])];
            this.setUsedMeshesList();
        }
    }
    /**
     * Returns the Whitelist Object
     */
    get whitelist() {
        return this._whitelist;
    }
    set whitelist(whitelist) {
        if (!whitelist.length) {
            this._whitelist = [];
        }
        else {
            this._whitelist = [...new Set([...this._whitelist, ...whitelist])];
            this.setUsedMeshesList();
        }
    }
    /**
     * Returns the _usedMeshesList Object
     */
    get usedMeshesList() {
        return this._usedMeshesList;
    }
    set usedMeshesList(usedMeshesList) {
        this._usedMeshesList = usedMeshesList;
    }
    setUsedMeshesList() {
        this._usedMeshesList = [];
        var meshes = this._scene.meshes;
        if (meshes.length) {
            for (let i = 0; i < meshes.length; i++) {
                if ((!this._whitelist.length ||
                    this._whitelist.indexOf(meshes[i].id) > -1) &&
                    (!this._blacklist.length ||
                        !this._blacklist.find(x => meshes[i].id.toLowerCase().includes(x.toLowerCase())))) {
                    this._usedMeshesList.push(meshes[i].id);
                }
                else if (this._blacklist.find(x => meshes[i].id.toLowerCase().includes(x.toLowerCase()))) {
                    meshes[i].isVisible = false;
                }
            }
        }
        // this.camera.refocusCamera(); 
    }
    /**
     * Enables/disables whether the user can control the camera.
     */
    get userInteractionEnabled() {
        return this._userInteractionEnabled;
    }
    set userInteractionEnabled(v) {
        this._userInteractionEnabled = v;
        if (this._scene && this._scene.activeCamera) {
            if (this._userInteractionEnabled) {
                this._scene.activeCamera.attachControl(this._canvasOverride);
            }
            else {
                this._scene.activeCamera.detachControl(this._canvasOverride);
            }
        }
    }
    // private _highlightLayer: BABYLON.HighlightLayer;
    /**
     * Register event callbacks for a list of meshes that should be selectable.
     * @param whitelistedMeshNames A list of mesh names that should be selectable. When using in combination with
     * {@link Garment3D}, have a look at {@link Garment3D.meshName} to obtain the mesh names in the scene.
     * @param callback A callback that provides the position where a mesh was selected.
     * The {@link meshName} returned by the callback will be `undefined` in case no mesh was selected.
     * @param selectionOutlineColor Optional. Specify an outline color the selected mesh should have.
     */
    registerOnMeshSelection(callback, selectionOutlineColor, zoomSelectedMesh) {
        //TODO: Change Highlightlayer with Glow Layer : https://doc.babylonjs.com/divingDeeper/mesh/glowLayer
        this._scene.onPointerObservable.add((pointerInfo) => {
            let event = pointerInfo.event;
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERDOWN:
                    console.log(this._scene.meshes);
                    callback({
                        type: BABYLON.PointerEventTypes.POINTERDOWN,
                        meshName: undefined,
                        mouseAttributes: { x: event.clientX, y: event.clientY, mouseButton: event.button }
                    });
                    // this._engine.inputElement = sceneSlot.canvas;
                    break;
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    //                   console.log("POINTER MOVE",this._scene.environmentTexture);
                    // let environment = this._scene.environmentTexture as BABYLON.HDRCubeTexture;
                    // environment.rotationY = this.camera.camera.alpha;
                    // if (!clicked) {
                    //   return;
                    // }
                    // console.log(environment.rotationY);
                    break;
                case BABYLON.PointerEventTypes.POINTERPICK:
                    let pickResult = pointerInfo.pickInfo;
                    if (callback) {
                        // this._highlightLayer.removeAllMeshes();
                        if (pickResult.hit && !this._blacklist.includes(pickResult.pickedMesh.name)) {
                            callback({
                                type: BABYLON.PointerEventTypes.POINTERPICK,
                                meshName: pickResult.pickedMesh.name,
                                mouseAttributes: { x: event.clientX, y: event.clientY, mouseButton: event.button }
                            });
                            if (selectionOutlineColor) {
                                const selectedMesh = this._scene.meshes.find(x => x.id == pickResult.pickedMesh.id);
                                if (zoomSelectedMesh && selectedMesh) {
                                    this._camera.zoomOnMeshes([selectedMesh]);
                                }
                                // this._highlightLayer.addMesh(selectedMesh, selectionOutlineColor);
                            }
                        }
                        else {
                            if (zoomSelectedMesh) {
                                this._camera.zoomOnMeshes();
                            }
                            callback({
                                type: null,
                                meshName: undefined,
                                mouseAttributes: { x: event.clientX, y: event.clientY, mouseButton: event.button }
                            });
                        }
                    }
                    else {
                        if (pickResult.hit && !this._blacklist.includes(pickResult.pickedMesh.name)) ;
                        else {
                            if (zoomSelectedMesh) {
                                this._camera.zoomOnMeshes();
                            }
                        }
                    }
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:
                    // pointerUp();
                    break;
            }
        });
        // this._scene.onPointerDown = (event, pickResult) => {
        // };
    }
    /**
     * Unregister the event callbacks for previously registered meshes.
     */
    unregisterOnMeshSelection() {
        this._scene.onPointerDown = null;
        // this._highlightLayer.removeAllMeshes();
    }
    /**
     * Sets/returns the background color of the canvas.
     */
    get backgroundColor() {
        return this._scene.clearColor;
    }
    set backgroundColor(v) {
        this._scene.clearColor = v;
    }
    loadCameraEnvironmentSettings(cameraSettings, environmentSettings = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let cameraSettingsJsonLoader;
            let environmentSettingsJsonLoader;
            if (typeof cameraSettings == 'string') {
                cameraSettingsJsonLoader = fetch(cameraSettings)
                    .then((response) => response.json())
                    .then((json) => {
                    this._cameraSettings = json;
                });
            }
            else {
                this._cameraSettings = cameraSettings;
            }
            if (typeof environmentSettings == 'string') {
                environmentSettingsJsonLoader = fetch(environmentSettings)
                    .then((response) => response.json())
                    .then((json) => {
                    this._environmentSettings = json;
                });
            }
            else {
                this._environmentSettings = environmentSettings;
            }
            let fetchList = [];
            if (cameraSettingsJsonLoader) {
                fetchList.push(cameraSettingsJsonLoader);
            }
            if (environmentSettingsJsonLoader) {
                fetchList.push(environmentSettingsJsonLoader);
            }
            yield Promise.all(fetchList)
                .then((fetchList) => {
                this.startScene();
                this._sceneReadyResolve();
            });
        });
    }
    loadSceneFiles(fileExtension = null) {
        this.loadFiles(fileExtension).then(() => {
            this.reRegisterOnMeshSelection();
            this._isLoaded = true;
            this._finishedResolve();
            this.sceneContainer.classList.remove('dc-bjs-loading-container');
            setTimeout(() => {
                if ((typeof this._environmentSettings === 'undefined' || !this._environmentSettings || typeof this._environmentSettings.backgroundColor === 'undefined') && typeof this._overwriteBackgroundColor == "undefined") {
                    this.backgroundColor = new BABYLON.Color4(0.9529, 0.9529, 0.9529, 1);
                }
                else {
                    if (typeof this._environmentSettings !== 'undefined' && this._environmentSettings && typeof this._environmentSettings.backgroundColor !== 'undefined') {
                        this.backgroundColor = this._environmentSettings.backgroundColor;
                    }
                    if (typeof this._overwriteBackgroundColor == "boolean") {
                        this.backgroundColor = new BABYLON.Color4(0.9529, 0.9529, 0.9529, 1);
                    }
                    else if (this._overwriteBackgroundColor) {
                        this.backgroundColor = this._overwriteBackgroundColor;
                    }
                }
            }, 10);
        });
    }
    reRegisterOnMeshSelection() {
        if (this._registerOnMeshSelection) {
            this.registerOnMeshSelection(this._registerOnMeshSelection.callback, this._registerOnMeshSelection.selectionOutlineColor, this._registerOnMeshSelection.zoomSelectedMesh);
        }
    }
    startScene() {
        /**
         * start scene:
         */
        this._scene.createDefaultLight();
        this.registersceneCallbacks();
        if (this._environmentTexturePath) {
            if (this._environmentFileType == 'hdr') {
                let reflectionTexture = new BABYLON.HDRCubeTexture(this._environmentTexturePath, this._scene, 512, false, true, false, true);
                reflectionTexture.level = 0.0001;
                reflectionTexture.gammaSpace = false;
                this._scene.environmentTexture = reflectionTexture;
            }
            else {
                var hdrTexture = new BABYLON.CubeTexture(this._environmentTexturePath, this._scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, '.' + this._environmentFileType); //BABYLON.CubeTexture.CreateFromPrefilteredData(this._environmentTexturePath, this._scene);
                hdrTexture.gammaSpace = false;
                this._scene.environmentTexture = hdrTexture;
                // let skybox = this._scene.createDefaultSkybox(hdrTexture, true, 1000);
                if (this._environmentSettings.cameraRotateEnvironment) {
                    this._scene.registerBeforeRender(() => {
                        var _a, _b;
                        //     texture.setReflectionTextureMatrix(BABYLON.Matrix.RotationX(BABYLON.Tools.ToRadians(alpha)));
                        let multiplyInvert = ((_a = this._environmentSettings) === null || _a === void 0 ? void 0 : _a.cameraRotateEnvironmentInvert) ? -1 : 1;
                        let environmentRotation = ((_b = this._environmentSettings) === null || _b === void 0 ? void 0 : _b.environmentRotation) ? this._environmentSettings.environmentRotation : 0;
                        hdrTexture.rotationY = (this.camera.camera.alpha + BABYLON.Tools.ToRadians(environmentRotation)) * multiplyInvert;
                    });
                }
            }
        }
        // this._highlightLayer = new BABYLON.HighlightLayer("hl-" + this._id, this._scene, {
        //   alphaBlendingMode: BABYLON.Engine.ALPHA_ADD,
        //   mainTextureFixedSize: 4096,
        //   blurTextureSizeRatio: .5,
        //   blurHorizontalSize: 30,
        //   blurVerticalSize: 30,
        //   isStroke: true
        // });
        // this._highlightLayer.outerGlow = false;
        // this._highlightLayer.innerGlow = true;
        if (this._environmentSettings) {
            this._environment = new DCEnvironmentHelper(this._scene, this._environmentSettings);
        }
        if (this._cameraSettings) {
            this._camera = new DCCamera(this);
        }
        this._scene.onReadyObservable.add((eventData, eventState) => {
            this.setUsedMeshesList();
            this._scene.blockMaterialDirtyMechanism = true;
            this._scene.meshes.forEach(mesh => {
                mesh.doNotSyncBoundingInfo = true;
                mesh.freezeWorldMatrix();
            });
            if (typeof this._environmentSettings.cameraRotateEnvironment === 'undefined' || null) {
                this._scene.materials.forEach(material => {
                    material.freeze();
                });
            }
            this._scene.animationGroups.forEach((animationGroup, index) => {
                animationGroup.stop();
            });
        });
    }
    changeGlassMaterial(searchReplaceName = 'glas') {
        var matReplace = searchReplaceName;
        var matReplaceArry = matReplace.split(',');
        if (matReplace && matReplaceArry.length) {
            var dcMaterial = new DCMaterial(this._scene);
            var glassMat = dcMaterial.getGlassMaterial(this._glassId);
            this._scene.meshes.forEach((mesh, i) => {
                if (typeof mesh.material !== 'undefined'
                    && mesh.material
                    && typeof mesh.material.id !== 'undefined'
                    && typeof matReplaceArry.find(x => mesh.material.id.includes(x)) !== 'undefined') {
                    mesh.material = glassMat;
                }
            });
        }
    }
    /**
     *
     * @param meshId Mesh ID
     * @param overwriteVisible true = force mesh to be visible, false = force mesh to be hidden, null = toggles visibility
     */
    toggleMeshVisibility(meshIds, overwriteVisible = null) {
        let meshes = Array.isArray(meshIds) ? meshIds : [meshIds];
        let isVisible = true;
        meshes.forEach(meshId => {
            meshId = meshId.replace('/', '_');
            let mesh = this.getMesh(meshId);
            let meshVisible = mesh.isVisible;
            mesh.isVisible = (overwriteVisible !== null) ? overwriteVisible : !meshVisible;
        });
        return isVisible;
    }
    showOnlyMesh(meshIds) {
        let meshes = Array.isArray(meshIds) ? meshIds : [meshIds];
        let isVisible = true;
        this.scene.meshes.forEach(mesh => {
            mesh.isVisible = false;
            meshes.forEach(meshId => {
                meshId = meshId.replace('/', '_');
                if (mesh.id.includes(meshId)) {
                    mesh.isVisible = true;
                }
            });
        });
        return isVisible;
    }
    changeMaterial(meshIds, materialId) {
        let meshes = Array.isArray(meshIds) ? meshIds : [meshIds];
        if (meshes.length) {
            meshes.forEach(meshId => {
                meshId = meshId.replace('/', '_');
                let mesh = this.getMesh(meshId);
                let material = this.getMaterial(materialId);
                if (mesh && material) {
                    mesh.material = material;
                }
                else {
                    console.log('Not found: ', ((!mesh) ? 'mesh: ' + meshId : (!material) ? 'material: ' + materialId : ''));
                }
            });
        }
    }
    getMesh(meshId, withoutPrefix = false) {
        if (!withoutPrefix) {
            let returnMesh = this._scene.getMeshById(meshId);
            if (returnMesh instanceof BABYLON.InstancedMesh) {
                returnMesh = returnMesh.sourceMesh;
            }
            return returnMesh;
        }
        else {
            let returnMesh = this._scene.meshes.find(x => x.id.includes(meshId));
            if (returnMesh instanceof BABYLON.InstancedMesh) {
                returnMesh = returnMesh.sourceMesh;
            }
            return returnMesh;
        }
    }
    getMaterial(materialId) {
        return this._scene.getMaterialById(materialId);
    }
    changeInfoMarkerImageSpritePosition(imageButtonId, position) {
        this._infopoints.changeButtonIconSprite(imageButtonId, position);
    }
    loadMarkersJson(markersPath, registerOnMarkerSelection) {
        fetch(markersPath)
            .then((response) => response.json())
            .then((json) => {
            this._markerJson = json;
            this._infopoints = new DCInfopoints(this);
            Object.keys(this._markerJson).forEach(type => {
                let markerValues = this._markerJson[type];
                markerValues.forEach(value => {
                    this._infopoints.addButton(value.id, type, Array.isArray(value.objects) ? value.objects : [value.objects], value.position, null, registerOnMarkerSelection);
                });
            });
        });
    }
    loadFiles(setFileExtension = null) {
        return new Promise((resolve, reject) => {
            if (this._assetsPath.length) {
                let promiseList = [];
                for (let i = 0; i < this._assetsPath.length; i++) {
                    var fileExtension = this._assetsPath[i].split('.').pop();
                    if (fileExtension == 'jpg' || fileExtension == 'png') {
                        promiseList.push(this.loadTexture(this._assetsPath[i]));
                    }
                    else if (fileExtension == 'mtl') {
                        promiseList.push(this.loadMTLFile(this._assetsPath[i]));
                    }
                    else if (fileExtension == 'obj' || fileExtension == 'glb' || fileExtension == 'gltf' || fileExtension == 'stl' || fileExtension == 'babylon' || this._assetsPath[i].includes('data:')) {
                        // console.log('Load: '+this._assetsPath[i]); 
                        promiseList.push(this.loadObject(this._assetsPath[i], (setFileExtension) ? setFileExtension : null));
                    }
                    else {
                        console.error('Fileextension: ' + fileExtension + ' is not supported', this._assetsPath[i].includes('data:'));
                    }
                    // }
                }
                Promise.all(promiseList)
                    .then((fetchList) => {
                    let meshes = this._assetContainers.map(x => x.meshes).reduce(function (pre, cur) {
                        return pre.concat(cur);
                    });
                    if (this._camera && meshes.length) {
                        this._camera.setCameraTarget(meshes);
                    }
                    resolve(true);
                });
            }
        });
    }
    activateSceneControlls() {
        var _a, _b;
        this._scene.attachControl();
        if ((_a = this.camera) === null || _a === void 0 ? void 0 : _a.camera) {
            this._scene.activeCamera = this.camera.camera;
        }
        if ((_b = this._scene) === null || _b === void 0 ? void 0 : _b.activeCamera) {
            this._scene.activeCamera.attachControl(this._canvasOverride);
        }
        this._sceneContainer.classList.add('active');
        this._canvasOverride.classList.add('active');
        this._isInputControlActive = true;
    }
    deactivateSceneControlls() {
        var _a, _b;
        this._scene.detachControl();
        (_b = (_a = this._scene) === null || _a === void 0 ? void 0 : _a.activeCamera) === null || _b === void 0 ? void 0 : _b.detachControl();
        this._sceneContainer.classList.remove('active');
        this._canvasOverride.classList.remove('active');
        this._isInputControlActive = false;
    }
    activateScene() {
        // if(!this._isSceneActive){
        this._assetContainers.forEach(aC => {
            aC.addAllToScene();
        });
        this._isSceneActive = true;
        // }      
        if (this._engineView) {
            this._engineView.enabled = true;
        }
    }
    deactivateScene(force = false) {
        // if(this._isSceneActive || force){
        this._assetContainers.forEach(aC => aC.removeAllFromScene());
        this._isSceneActive = false;
        // }      
        if (this._engineView) {
            this._engineView.enabled = false;
        }
    }
    overrideCanvas(canvas) {
        let canvasElement = (typeof canvas === "string") ? document.querySelector(canvas) : canvas;
        this._canvasOverride = canvasElement;
        this._scene.activeCamera.attachControl(this._canvasOverride);
    }
    resetCanvas() {
        this._canvasOverride = this._canvas;
    }
    meshWrite(text, mesh, fontType = "arial", size = 20, color = 'white', left = 0, top = null, fixResolution = 500, letterspacing = 1, oLineHeight = 1) {
        let writeMesh;
        if (typeof mesh === 'string') {
            writeMesh = this.getMesh(mesh, true);
        }
        else {
            writeMesh = mesh;
        }
        var vectorsWorld = writeMesh.getBoundingInfo().boundingBox.vectorsWorld;
        let DTWidth = Math.abs(parseFloat((vectorsWorld[1].x - vectorsWorld[0].x).toFixed(10)));
        let DTHeight = Math.abs(parseFloat((vectorsWorld[1].y - vectorsWorld[0].y).toFixed(10)));
        let resolution = (fixResolution * 2 / DTWidth + fixResolution * 2 / DTHeight + fixResolution * 8) / 2;
        var text = text;
        //Create dynamic texture
        var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", { width: DTWidth * resolution, height: DTHeight * resolution }, this._scene);
        //Check width of text for given font type at any size of font
        // var ctx = dynamicTexture.getContext();
        // ctx.font = size + "px " + fontType;
        // var textWidth = ctx.measureText(text).width;
        //Calculate ratio of text width to size of font used
        // var ratio = size; //textWidth/size;
        //set font to be actually used to write text on dynamic texture
        var ration = (resolution * DTWidth / fixResolution);
        var font_size = size * ration; //size of multiplier (1) can be adjusted, increase for smaller text
        var font = font_size + "px " + fontType;
        var lineHeight = font_size;
        //Draw text
        let textMultiline = text.split('<br>');
        if (textMultiline && textMultiline.length) {
            var linePosition = (top) ? top * font_size : 0;
            textMultiline.forEach(lineText => {
                if (letterspacing) {
                    let leftStart = (left * font_size);
                    lineText.split("").forEach(char => {
                        dynamicTexture.drawText(char, leftStart, linePosition, font, color, 'transparent', false);
                        var ctx = dynamicTexture.getContext();
                        ctx.font = font;
                        var textWidth = ctx.measureText(char).width;
                        leftStart += (textWidth + font_size * letterspacing);
                    });
                }
                else {
                    dynamicTexture.drawText(lineText, (left * font_size), linePosition, font, color, 'transparent', false);
                }
                linePosition += ((oLineHeight) ? oLineHeight * font_size : lineHeight);
            });
        }
        //create material
        let writeMaterialId = "writetext-mat-" + this.id;
        let mat = this.scene.getMaterialById(writeMaterialId);
        if (mat) {
            mat.diffuseTexture = dynamicTexture;
            mat.diffuseTexture.hasAlpha = true;
            mat.useAlphaFromDiffuseTexture = true;
            mat.disableLighting = true;
            mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
        }
        else {
            mat = new BABYLON.StandardMaterial("writetext-mat-" + this.id, this._scene);
            mat.diffuseTexture = dynamicTexture;
            mat.diffuseTexture.hasAlpha = true;
            mat.useAlphaFromDiffuseTexture = true;
            mat.disableLighting = true;
            mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
            //apply material
            writeMesh.material = mat;
        }
    }
    loadPromise(root, file, scene, fileExtension = null) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((res, rej) => {
                BABYLON.SceneLoader.LoadAssetContainer('./', file, scene, function (container) {
                    let start = (file.length > 100) ? 0 : file.lastIndexOf("/") + 1;
                    let end = (file.length > 100) ? 5 : file.lastIndexOf(".");
                    let filename = file.substring(start, end);
                    container.meshes = container.meshes.filter(x => x.id != "__root__");
                    container.meshes.forEach(mesh => mesh.id = filename + '_' + mesh.id);
                    container.transformNodes.forEach(node => node.id = filename + '_' + node.id);
                    container.materials.forEach(material => material.id = filename + '_' + material.id);
                    res(container);
                }, null, null, (fileExtension) ? fileExtension : null);
            });
        });
    }
    loadObject(url, fileExtension = null) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.sceneContainer.classList.add('dc-bjs-loading-container');
                this._startedResolve();
                // The first parameter can be set to null to load all meshes and skeletons
                // const result : BABYLON.ISceneLoaderAsyncResult = await BABYLON.SceneLoader.ImportMeshAsync("", "./", url, this._scene);
                //const result : BABYLON.ISceneLoaderPluginAsync | BABYLON.ISceneLoaderPlugin = await BABYLON.SceneLoader.LoadAssetContainer("./", url, this._scene); // ImportMeshAsync("", "./", url, this._scene);
                this.loadPromise("./", url, this._scene, fileExtension).then((result) => {
                    // check if loaded results already loaded in any assetContainer
                    if (!this._assetContainers.length ||
                        !this._assetContainers.map(x => x.meshes)
                            .reduce(function (pre, cur) {
                            return pre.concat(cur);
                        })
                            .map(x => x.id).join('').includes(result.meshes.map(x => x.id).join(''))) {
                        this._assetContainers.push(result);
                        if (result.meshes.length) {
                            let meshes = [];
                            this._assetContainers.forEach(aC => {
                                meshes = meshes.concat(...aC.meshes);
                            });
                            resolve(meshes);
                        }
                    }
                    else {
                        resolve(this._assetContainers.map(x => x.meshes)
                            .reduce(function (pre, cur) {
                            return pre.concat(cur);
                        }));
                    }
                }, (reason) => {
                    console.error('failed to load Objects: ', reason);
                    reject(reason);
                });
            });
        });
    }
    // TODO: add LoadTexture for .obj files
    loadTexture(url) {
        return new Promise((resolve, reject) => {
            resolve(true);
        });
    }
    loadMTLFile(url) {
        // The first parameter can be set to null to load all meshes and skeletons
        return new Promise((resolve, reject) => {
            this._startedResolve();
            let mtlLoader = new BABYLON.MTLFileLoader();
            mtlLoader.parseMTL(this._scene, url, "./", null);
            resolve(true);
        });
    }
    registersceneCallbacks() {
        this._scene.onNewMaterialAddedObservable.add(this.sceneCallbacks.addMaterial);
        this._scene.onNewMeshAddedObservable.add(this.sceneCallbacks.addMesh);
        this._scene.onNewLightAddedObservable.add(this.sceneCallbacks.addLight);
    }
}

class DCModal {
    constructor(viewer, scene, id, copyToContainer, downloadButtonText = 'Bild herunterladen') {
        this._scene = scene;
        this._copyElement = this._scene.canvasOverride;
        this._copyElementContainer = this._scene.sceneContainer;
        this._copyToContainer = document.querySelector('body');
        if (copyToContainer) {
            this._copyToContainer = (copyToContainer && typeof copyToContainer === 'string') ? document.querySelector(copyToContainer) : copyToContainer;
        }
        this._viewer = viewer;
        this._id = id;
        this.createModal(downloadButtonText);
    }
    get id() {
        return this._id;
    }
    createModal(downloadButtonText = 'Bild herunterladen') {
        this.modal = document.createElement('div');
        this.modal.id = this._id;
        this.modal.classList.add("dc-modal");
        this._divModalContentContainer = document.createElement('div');
        this._divModalContentContainer.classList.add("dc-modal-content-container");
        var divModalContentContainerInner = document.createElement('div');
        divModalContentContainerInner.classList.add("inner");
        this._divModalClose = document.createElement('a');
        this._divModalClose.classList.add("dc-btn-close");
        this._divModalClose.innerHTML = '&#10006;';
        this._divModalContent = document.createElement('div');
        this._divModalContent.classList.add("dc-modal-content");
        this._divModalImageContainer = document.createElement('div');
        this._divModalImageContainer.classList.add("dc-modal-image-container");
        var divModalImageContainerInner = document.createElement('div');
        divModalImageContainerInner.classList.add("dc-image-container");
        this._divModalImage = document.createElement('img');
        this._divModalImage.classList.add("dc-renderimage");
        this._divModalDownload = document.createElement('a');
        this._divModalDownload.classList.add("dc-download");
        this._divModalDownload.innerHTML = downloadButtonText;
        this.modal.appendChild(this._divModalContentContainer);
        this._divModalContentContainer.appendChild(divModalContentContainerInner);
        divModalContentContainerInner.appendChild(this._divModalClose);
        divModalContentContainerInner.appendChild(this._divModalContent);
        divModalContentContainerInner.appendChild(this._divModalImageContainer);
        this._divModalImageContainer.appendChild(divModalImageContainerInner);
        divModalImageContainerInner.appendChild(this._divModalImage);
        this._divModalImageContainer.appendChild(this._divModalDownload);
        this.modal.addEventListener('click', (event) => {
            if (!(event.target instanceof Element && event.target.classList.contains('dc-download'))) {
                event.preventDefault();
                this.hide();
            }
        });
        this._divModalContentContainer.addEventListener('click', (event) => {
            if (!(event.target instanceof Element && event.target.classList.contains('dc-download'))) {
                event.preventDefault();
                event.stopPropagation();
            }
        });
        return (this.modal);
    }
    screenshot(screenshotWidth, screenshotHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            var imageSrc = yield this._viewer.takeScreenshot(this._scene, { width: screenshotWidth, height: screenshotHeight });
            this._divModalImage.src = imageSrc;
            this._divModalDownload.href = imageSrc;
            this._divModalDownload.download = 'screenshot.png';
        });
    }
    show(scene = this._scene, headline = "", fullscreen = true, takeScreenshot = false, screenshotWidth = 1920, screenshotHeight = 1080) {
        this._scene = scene;
        this._copyElement = this._scene.sceneContainer;
        this._copyElementContainer = this._scene.scenePlaceholder;
        var body = document.querySelector('body');
        this._divModalContent.innerHTML = '';
        if (headline != '') {
            this._divModalContent.innerHTML = '<h3>' + headline + '</h3>';
        }
        if (takeScreenshot === true) {
            this.screenshot(screenshotWidth, screenshotHeight);
            this._divModalImageContainer.classList.remove('dc-hidden');
            this._divModalContent.classList.add('dc-hidden');
        }
        else {
            this._divModalImageContainer.classList.add('dc-hidden');
            this._divModalContent.classList.remove('dc-hidden');
        }
        if (fullscreen === true) {
            body.prepend(this.modal);
            body.classList.add('dc-modal-active');
            this._scene.isFullscreen = true;
            this._divModalContentContainer.classList.add('fullscreen');
            if (this._copyElement) {
                this._divModalContent.appendChild(this._copyElement);
            }
            // this.modal.requestFullscreen(); 
        }
        else if (this._copyToContainer) {
            this._copyToContainer.appendChild(this.modal);
            this._copyToContainer.classList.add('dc-modal-added');
        }
        if (this._divModalClose) {
            this._divModalClose.addEventListener('click', (event) => {
                event.preventDefault();
                this.hide();
            });
        }
        setTimeout(() => { this._viewer.resize(); }, 40);
        this.modal.classList.add('fadeIn');
    }
    hide() {
        this._divModalContentContainer.classList.remove('fullscreen');
        var body = document.querySelector('body');
        if (this._copyElement && this._copyElementContainer) {
            this._copyElementContainer.appendChild(this._copyElement);
            setTimeout(() => { this._viewer.resize(); }, 10);
        }
        // copyToContainer.prepend(modal);
        if (this._copyToContainer) {
            this._copyToContainer.classList.remove('dc-modal-added');
        }
        body.classList.remove('dc-modal-active');
        // scene.infopointsToggleVisibility(true);
        this._scene.isFullscreen = false;
        this.modal.classList.remove('fadeIn');
        this.modal.remove();
        // setTimeout(()=>{
        //     this.modal.parentNode.removeChild(this.modal); 
        // }, 500); 
    }
    remove() {
        this.modal.parentNode.removeChild(this.modal);
    }
}

class DCBabylonJsViewer {
    constructor() {
        this._sceneSlots = [];
        this._viewerSingleModus = false;
        this._modals = [];
        let element = document.createElement("canvas");
        this._engine = new BABYLON.Engine(element, true, { preserveDrawingBuffer: true, stencil: true }, false);
        this._engine.runRenderLoop(() => {
            this._sceneSlots.forEach(scene => {
                var _a, _b, _c, _d;
                if (scene.isLoaded && scene.isSceneActive) {
                    if (((_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.activeView) === null || _b === void 0 ? void 0 : _b.target) === scene.canvasOverride) {
                        scene.scene.render();
                    }
                    else if ((!((_d = (_c = this._engine) === null || _c === void 0 ? void 0 : _c.activeView) === null || _d === void 0 ? void 0 : _d.target) && !this._viewerSingleModus)) {
                        scene.scene.render();
                    }
                }
            });
        });
        window.addEventListener("resize", () => {
            this._engine.resize();
        });
        var lastScrollTop = 0;
        window.addEventListener('scroll', () => {
            if (!this._viewerSingleModus) {
                var scrollDirection = 'down';
                var st = window.pageYOffset || document.documentElement.scrollTop; // Credits: "https://github.com/qeremy/so/blob/master/so.dom.js#L426"
                if (st > lastScrollTop) {
                    scrollDirection = 'down';
                }
                else {
                    scrollDirection = 'up';
                }
                lastScrollTop = st <= 0 ? 0 : st; // For Mobile or negative scrolling
                this.setScenesInViewState(scrollDirection);
            }
        });
        window.addEventListener('load', (event) => {
            if (!this._viewerSingleModus) {
                this.setScenesInViewState('down');
            }
        });
    }
    /**
     * Returns the underlying BABYLON.Engine instance.
     */
    get engine() {
        return this._engine;
    }
    /**
     * Returns the underlying BABYLON.Engine instance.
     */
    get sceneSlots() {
        return this._sceneSlots;
    }
    openModal(scene, id, container = null, headline = '', fullscreen = false, screenshot = true, downloadButtonText = 'Bild herunterladen') {
        let modal = this._modals.find(x => x.id == id);
        if (typeof modal === 'undefined') {
            modal = new DCModal(this, scene, id, container, downloadButtonText);
        }
        modal.show(scene, headline, fullscreen, screenshot);
        return modal;
    }
    closeModal(id) {
        let modal = this._modals.find(x => x.id == id);
        if (modal && typeof modal !== 'undefined') {
            modal.hide();
        }
        return modal;
    }
    setScenesInViewState(scrollDirection) {
        this._sceneSlots.forEach(scene => {
            if (this.isInViewport(scene.sceneContainer)) {
                this.startScene(scene);
            }
            else {
                this.stopScene(scene);
            }
        });
    }
    switchViewModusToSingle(canvas) {
        let singleCanvas = (typeof canvas === "string") ? document.querySelector(canvas) : canvas;
        this._sceneSlots.forEach(scene => {
            this.stopScene(scene);
            this._engine.unRegisterView(scene.canvas);
            scene.engineView = null;
            scene.overrideCanvas(singleCanvas);
        });
        this.loadScene(this._sceneSlots[0], singleCanvas);
        this._viewerSingleModus = true;
    }
    switchViewModusToMulti() {
        this._viewerSingleModus = false;
        this._sceneSlots.forEach(scene => {
            scene.resetCanvas();
            this.loadScene(scene);
        });
    }
    addScene(canvas, sceneContainer, scenePlaceholder, assetsPath, cameraSettings = null, environmentSettings = null, registerOnMeshSelection = null, environmentTexturePath = "", environmentTextureExtension = "") {
        let canvasElement = (typeof canvas === "string") ? document.querySelector(canvas) : canvas;
        let scene = new BABYLON.Scene(this._engine);
        let sceneSlot = new DCSceneSlot(canvasElement, sceneContainer, scenePlaceholder, scene, (this._sceneSlots.length + 1).toString(), assetsPath, cameraSettings, environmentSettings, registerOnMeshSelection, environmentTexturePath, environmentTextureExtension);
        this._sceneSlots.push(sceneSlot);
        sceneSlot.sceneReady.then(() => {
            sceneSlot.canvas.addEventListener('wheel', evt => evt.preventDefault());
            let handlerActive = false;
            let handlerEnter = (e) => {
                if (!handlerActive && e.isPrimary) {
                    handlerActive = true;
                    if (!this._viewerSingleModus) {
                        this._engine.inputElement = null;
                        this._sceneSlots.forEach(x => {
                            if (x !== sceneSlot) {
                                x.deactivateSceneControlls();
                            }
                            else {
                                x.activateSceneControlls();
                                if (this._engine.inputElement != sceneSlot.canvasOverride) {
                                    this._engine.inputElement = sceneSlot.canvasOverride;
                                }
                            }
                        });
                    }
                }
            };
            let handlerLeave = (event) => {
                if (event.isPrimary) {
                    handlerActive = false;
                }
            };
            ['pointerenter'].forEach(event => sceneSlot.canvasOverride.parentNode.addEventListener(event, handlerEnter));
            ['pointerleave'].forEach(event => sceneSlot.canvasOverride.parentNode.addEventListener(event, handlerLeave)); // 
        });
        if (typeof this.loadingFinished !== 'undefined') {
            sceneSlot.loadingFinished.then(() => {
                this.loadingFinished(canvasElement);
            });
        }
        if (typeof this.loadingStarted !== 'undefined') {
            sceneSlot.loadingStarted.then(() => {
                this.loadingStarted(canvasElement);
            });
        }
        return sceneSlot;
    }
    fullscreen(scene) {
        scene.scenePlaceholder.requestFullscreen();
        // this._engine.enterFullscreen(true); 
        this.resize();
    }
    loadScene(scene, overwriteCanvas = null) {
        let canvas = (overwriteCanvas) ? ((typeof overwriteCanvas === "string") ? document.querySelector(overwriteCanvas) : overwriteCanvas) : scene.canvasOverride;
        scene.camera.changeCanvas(canvas);
        scene.engineView = this._engine.registerView(canvas, scene.scene.activeCamera, true);
        if (this._viewerSingleModus) {
            this.sceneSlots.forEach((x, index) => {
                if (x !== scene) {
                    this.stopScene(x);
                }
            });
            setTimeout(() => {
                this.startScene(scene);
            }, 0);
        }
        else {
            this.startScene(scene);
        }
    }
    startScene(scene) {
        scene.activateScene();
    }
    stopScene(scene) {
        scene.deactivateScene();
    }
    nextScene(overwriteCanvas = null) {
        if (this._viewerSingleModus) {
            let activeSceneIndex = this._sceneSlots.indexOf(this._sceneSlots.find(x => x.isSceneActive));
            if (activeSceneIndex > -1) {
                activeSceneIndex++;
                if (activeSceneIndex >= this._sceneSlots.length) {
                    activeSceneIndex = 0;
                }
                this.loadScene(this._sceneSlots[activeSceneIndex], overwriteCanvas);
            }
            else {
                console.log('Scene not found ');
            }
        }
    }
    prevScene(overwriteCanvas = null) {
        if (this._viewerSingleModus) {
            let activeSceneIndex = this._sceneSlots.indexOf(this._sceneSlots.find(x => x.isSceneActive));
            if (activeSceneIndex > -1) {
                activeSceneIndex--;
                if (activeSceneIndex < 0) {
                    activeSceneIndex = this._sceneSlots.length - 1;
                }
                this.loadScene(this._sceneSlots[activeSceneIndex], overwriteCanvas);
            }
            else {
                console.log('Scene not found ');
            }
        }
    }
    /**
     * Triggers the resize event which will re-render the scene with the new canvas dimensions to keep the right proportions.
     */
    resize() {
        if (!this.engine) {
            return;
        }
        this.engine.resize();
    }
    /**
     * Renders the current scene, displayed by the active camera to a png file encoded as a base64 string.
     * @param size Interface for size & precision parameters.
     * @returns A png image encoded as a base64 data URI string.
     */
    takeScreenshot(sceneSlot, size, camera = null) {
        return __awaiter(this, void 0, void 0, function* () {
            sceneSlot.scene.render(); // make sure the scene is already rendered
            let renderCamera = camera;
            if (!camera) {
                renderCamera = sceneSlot.scene.activeCamera;
            }
            return yield BABYLON.Tools.CreateScreenshotUsingRenderTargetAsync(this._engine, renderCamera, size, undefined, undefined, true);
        });
    }
    isInViewport(mainContainer) {
        const { top, bottom } = mainContainer.getBoundingClientRect();
        const vHeight = (window.innerHeight || document.documentElement.clientHeight);
        return ((top > 0 || bottom > 0) &&
            top < vHeight);
    }
}

export { DCBabylonJsViewer, DCCamera, DCCameraSettingsModel, DCEnvironmentHelper, DCEnvironmentSettingsModel, DCInfopointClickReturnModel, DCInfopoints, DCMarkers, DCMaterial, DCSceneSlot };
//# sourceMappingURL=duncrow-bjs-viewer.js.map
